#! /usr/bin/env perl6

use v6.d;
use Term::ReadKey;

our &BOLD = sub (*@s) {
    "\e[1m{@s.join('')}\e[0m"
}

our &RED = sub (*@s) {
    "\e[31m{@s.join('')}\e[0m"
}

our &RESET = sub (*@s) {
    "\e[0m{@s.join('')}\e[0m"
}

&BOLD = &RED = &RESET = sub (Stringy $s) { $s } unless $*OUT.t;

sub cache(\seq) { seq.cache }

my %cache-mapping;

sub is-bcache-dev($dev) {
    "/sys/block/$dev/bcache/cache".IO.e
}

sub bcache-devs() {
    gather for dir('/sys/block/')».basename -> $dev {
        if is-bcache-dev($dev) {
            %cache-mapping{"/sys/block/$dev/bcache/cache".IO.resolve.basename}.push: $dev;
            $dev.take;
        }
    }
}

sub bcache-caches() {
    gather for dir('/sys/fs/bcache/') { .basename.take if .basename.contains('-') }
}

my @stats = 
    'cache state', -> $dev { slurp("/sys/block/$dev/bcache/state").chomp  },
    'cache mode', -> $dev { slurp("/sys/block/$dev/bcache/cache_mode").chomp ~~ /'[' (\w+) ']'/; $0 },
    'dirty data', -> $dev { slurp("/sys/block/$dev/bcache/dirty_data").chomp  },
    'keep dirty', -> $dev { slurp("/sys/block/$dev/bcache/writeback_percent").chomp ~ '%'  },
    'devices', -> $dev { dir("/sys/block/$dev/slaves/")».basename.chomp.join(' ') },
    'device', -> $cache {
        my @devs;
        for 0..∞ -> $i {
            my $path = "/sys/fs/bcache/$cache/cache{$i}".IO;
            last unless $path.e;
            @devs.push: $path.resolve.Str.split('/')[*-2]
        }
        @devs.join(' ')
    },
    'serving', -> $cache { quietly %cache-mapping{$cache}.join(' ') || 'detached' },
    'hit ratio', -> $cache { 
        slurp("/sys/fs/bcache/$cache/stats_total/cache_hit_ratio").chomp ~ '%',
        slurp("/sys/fs/bcache/$cache/stats_day/cache_hit_ratio").chomp ~ '%/d',
        slurp("/sys/fs/bcache/$cache/stats_hour/cache_hit_ratio").chomp ~ '%/h',
        slurp("/sys/fs/bcache/$cache/stats_five_minute/cache_hit_ratio").chomp ~ '%/5min'
    },
    'bypassed',  -> $cache {
        slurp("/sys/fs/bcache/$cache/stats_total/bypassed").chomp,      
        slurp("/sys/fs/bcache/$cache/stats_day/bypassed").chomp ~ '/d',
        slurp("/sys/fs/bcache/$cache/stats_hour/bypassed").chomp ~ '/h',
        slurp("/sys/fs/bcache/$cache/stats_five_minute/bypassed").chomp ~ '/5min'
    },
    'cache available', -> $cache {
        slurp("/sys/fs/bcache/$cache/cache_available_percent").chomp ~ '%'
    },
    'written to cache', -> $cache { slurp("/sys/fs/bcache/$cache/cache0/written").chomp },
    'btree written', -> $cache { slurp("/sys/fs/bcache/$cache/cache0/btree_written").chomp },
;

my %stats = do for @stats -> $key, &value { 
    slip $key.subst(' ', '-', :g), &value
}

multi sub MAIN() {
    for bcache-devs() -> $dev {
        with $dev {
            say BOLD $dev, ':';
            for @stats -> $name, &f {
                next unless &f.signature.params».name eq '$dev';
                put "\t", $name, ': ', .&f
            }
        }
    }
    for bcache-caches() -> $cache {
        say BOLD $cache, ':';
        with $cache {
            for @stats -> $name, &f {
                next unless &f.signature.params».name eq '$cache';
                put "\t", $name, ': ', .&f
            }
        }
    }
}

multi sub MAIN($delay) {
    react {
        whenever Supply.interval($delay) {
            MAIN();
            put "";
        }
        whenever key-pressed(:!echo) {
            when 'q' | 'Q' { done }
        }
    }
}
