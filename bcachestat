#! /usr/bin/env perl6

use v6.d;
use Term::ReadKey;

our &BOLD = sub (*@s) {
    "\e[1m{@s.join('')}\e[0m"
}

our &RED = sub (*@s) {
    "\e[31m{@s.join('')}\e[0m"
}

our &RESET = sub (*@s) {
    "\e[0m{@s.join('')}\e[0m"
}

&BOLD = &RED = &RESET = sub (Stringy $s) { $s } unless $*OUT.t;

constant \bcache-devs = gather for dir('/sys/block/') { .basename.take if .basename.starts-with('bcache') }

constant \bcache-caches = gather for dir('/sys/fs/bcache/') { .basename.take if .basename.contains('-') }

my @stats = 
    'cache state', -> $dev { slurp("/sys/block/$dev/bcache/state").chomp  },
    'cache mode', -> $dev { slurp("/sys/block/$dev/bcache/cache_mode").chomp ~~ /'[' (\w+) ']'/; $0 },
    'dirty data', -> $dev { slurp("/sys/block/$dev/bcache/dirty_data").chomp  },
    'device', -> $cache {
        my @devs;
        for 0..∞ -> $i {
            my $path = "/sys/fs/bcache/$cache/cache{$i}".IO;
            last unless $path.e;
            @devs.push: $path.resolve.Str.split('/')[*-2]
        }
        @devs.join(' ')
    },
    'hit ratio', -> $cache { 
        slurp("/sys/fs/bcache/$cache/stats_total/cache_hit_ratio").chomp ~ '%',
        slurp("/sys/fs/bcache/$cache/stats_day/cache_hit_ratio").chomp ~ '%/d',
        slurp("/sys/fs/bcache/$cache/stats_hour/cache_hit_ratio").chomp ~ '%/h',
        slurp("/sys/fs/bcache/$cache/stats_five_minute/cache_hit_ratio").chomp ~ '%/5min'
    },
    'bypassed',  -> $cache {
        slurp("/sys/fs/bcache/$cache/stats_total/bypassed").chomp,      
        slurp("/sys/fs/bcache/$cache/stats_day/bypassed").chomp ~ '/d',
        slurp("/sys/fs/bcache/$cache/stats_hour/bypassed").chomp ~ '/h',
        slurp("/sys/fs/bcache/$cache/stats_five_minute/bypassed").chomp ~ '/5min'
    },
    'cache available', -> $cache {
        slurp("/sys/fs/bcache/$cache/cache_available_percent").chomp ~ '%'
    },
    'written to cache', -> $cache { slurp("/sys/fs/bcache/$cache/cache0/written").chomp },
    'btree written', -> $cache { slurp("/sys/fs/bcache/$cache/cache0/btree_written").chomp },
;

multi sub MAIN() {
    my %cache-mapping;
    for bcache-devs -> $dev {
        with $dev {
            %cache-mapping{"/sys/block/$dev/bcache/cache".IO.resolve.basename}.push: .Str;

            say BOLD $dev, ':';
            for @stats -> $name, &f {
                next unless &f.signature.params».name eq '$dev';
                put "\t", $name, ': ', .&f
            }
        }
    }
    put "";
    for bcache-caches -> $cache {
        my $attached-to = quietly %cache-mapping{$cache}.join(' ') || 'detached';
        say BOLD $cache, ':';
        with $cache {
            say "\t", 'serving: ', $attached-to;
            for @stats -> $name, &f {
                next unless &f.signature.params».name eq '$cache';
                put "\t", $name, ': ', .&f
            }
        }
    }
}

multi sub MAIN($delay) {
    react {
        whenever Supply.interval($delay) {
            MAIN();
        }
        whenever key-pressed(:!echo) {
            when 'q' | 'Q' { done }
        }
    }
}
